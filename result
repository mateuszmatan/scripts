#!/bin/bash

# ==============================================================================
# Script to find and analyze certificates on the filesystem using standard tools.
# V10: Adds an explicit passwordless 'keytool' fallback for JKS files.
# ==============================================================================

# --- Configuration ---
OUTPUT_FILE="certificate_report_v10.json"
# Passwords to try (passwordless attempt is now a separate fallback)
DEFAULT_PASSWORDS=("changeit" "password" "secret" "keystore") 

# --- Color Definitions ---
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m' # No Color

# --- Global Data ---
CURRENT_MACHINE_NAME=$(hostname)
CURRENT_MACHINE_IP=$(hostname -I | awk '{print $1}')
KEYTOOL_AVAILABLE=false

# ==============================================================================
# Function: Checks for required and optional dependencies.
# ==============================================================================
check_dependencies() {
    # Check for mandatory tools
    for cmd in find openssl; do
        if ! command -v "$cmd" &> /dev/null; then
            echo -e "${RED}FATAL ERROR: Required tool '$cmd' is not installed. Exiting.${NC}" >&2
            exit 1
        fi
    done
    
    # Check for optional tool: keytool
    if command -v "keytool" &> /dev/null; then
        KEYTOOL_AVAILABLE=true
    else
        echo -e "${YELLOW}WARNING: 'keytool' utility not found. Java KeyStore files (.jks, etc.) will be skipped.${NC}" >&2
    fi
}

# ==============================================================================
# Function: Escapes a string for use as a JSON value.
# ==============================================================================
json_escape() {
    echo -n "$1" | sed -e 's/\\/\\\\/g' -e 's/"/\\"/g' -e 's/\//\\\//g' -e 's/\b/\\b/g' -e 's/\f/\\f/g' -e 's/\n/\\n/g' -e 's/\r/\\r/g' -e 's/\t/\\t/g'
}

# ==============================================================================
# Function: Prints and generates a JSON object for an error.
# ==============================================================================
generate_error_json() {
    local filepath="$1"
    local error_msg="$2"

    if [ -z "$error_msg" ]; then
        error_msg="Operation failed without a specific error message."
    fi

    printf "${RED}Error Found:${NC}\n" >&2
    printf "     ${BOLD}File:${NC}  %s\n" "$filepath" >&2
    printf "     ${BOLD}Error:${NC} %s\n" "$error_msg" | sed 's/.*: // ' >&2

    local escaped_path=$(json_escape "$filepath")
    local escaped_error=$(json_escape "$error_msg")

    printf '{"filePath":"%s","error":"%s"}' "$escaped_path" "$escaped_error"
}

# ==============================================================================
# Function: Prints and generates a JSON object for a valid certificate.
# ==============================================================================
parse_valid_cert_to_json() {
    local filepath="$1"
    local cert_pem_content="$2"

    local issuer=$(echo "$cert_pem_content" | openssl x509 -noout -issuer | sed 's/issuer=//')
    local valid_from_str=$(echo "$cert_pem_content" | openssl x509 -noout -startdate | cut -d= -f2-)
    local valid_to_str=$(echo "$cert_pem_content" | openssl x509 -noout -enddate | cut -d= -f2-)
    local key_usage=$(echo "$cert_pem_content" | openssl x509 -noout -text | grep -A1 'X509v3 Key Usage:' | tail -n1 | sed 's/^\s*//')
    
    local valid_from_ts=$(date -d "$valid_from_str" +%s 2>/dev/null)
    local valid_to_ts=$(date -d "$valid_to_str" +%s 2>/dev/null)
    local now_ts=$(date +%s)
    
    if [ -z "$valid_from_ts" ] || [ -z "$valid_to_ts" ]; then
        generate_error_json "$filepath" "Failed to parse date strings: '$valid_from_str' / '$valid_to_str'"
        return
    fi
    
    local valid_from_iso=$(date -d "@$valid_from_ts" -u --iso-8601=seconds)
    local valid_to_iso=$(date -d "@$valid_to_ts" -u --iso-8601=seconds)
    local days_valid=$(( (valid_to_ts - valid_from_ts) / 86400 ))

    local status_color
    local status_text
    local is_valid
    if (( now_ts > valid_to_ts || now_ts < valid_from_ts )); then
        status_color="${RED}"
        status_text="EXPIRED / INACTIVE"
        is_valid="false"
    else
        is_valid="true"
        local seconds_remaining=$((valid_to_ts - now_ts))
        local days_remaining=$((seconds_remaining / 86400))
        if [ "$days_remaining" -le 30 ]; then
            status_color="${YELLOW}"
            status_text="VALID (Expires in ${days_remaining} days!)"
        else
            status_color="${GREEN}"
            status_text="VALID (Expires in ${days_remaining} days)"
        fi
    fi
    
    printf "${GREEN}Certificate Details:${NC}\n" >&2
    printf "     ${BOLD}Issuer:${NC}   %s\n" "$issuer" >&2
    printf "     ${BOLD}Status:${NC}   %b%s${NC}\n" "$status_color" "$status_text" >&2
    printf "     ${BOLD}Validity:${NC} From %s to %s (%d days total)\n" "$(date -d "$valid_from_str" '+%Y-%m-%d')" "$(date -d "$valid_to_str" '+%Y-%m-%d')" "$days_valid" >&2
    if [ -n "$key_usage" ]; then printf "     ${BOLD}Usage:${NC}    %s\n" "$key_usage"; fi >&2

    local json_output="{"
    json_output+=$(printf '"filePath":"%s",' "$(json_escape "$filepath")")
    if [ -n "$issuer" ]; then json_output+=$(printf '"issuer":"%s",' "$(json_escape "$issuer")"); fi
    json_output+=$(printf '"validFrom":"%s",' "$(json_escape "$valid_from_iso")")
    json_output+=$(printf '"validTo":"%s",' "$(json_escape "$valid_to_iso")")
    json_output+=$(printf '"daysValid":%d,' "$days_valid")
    json_output+=$(printf '"isValid":%s,' "$is_valid")
    if [ -n "$key_usage" ]; then json_output+=$(printf '"keyUsage":"%s",' "$(json_escape "$key_usage")"); fi
    json_output+=$(printf '"currentMachineName":"%s",' "$(json_escape "$CURRENT_MACHINE_NAME")")
    json_output+=$(printf '"currentMachineIP":"%s",' "$(json_escape "$CURRENT_MACHINE_IP")")
    
    json_output=$(echo "${json_output%,}}")"}"
    echo "$json_output"
}

# ==============================================================================
# Function: Processes standard certificate files (PEM, DER, etc.).
# ==============================================================================
process_openssl_file() {
    local filepath="$1"
    local cert_content
    local exit_code
    local ERR_FILE=$(mktemp)
    
    cert_content=$(openssl x509 -in "$filepath" -inform pem -passin pass:'' 2> "$ERR_FILE")
    exit_code=$?
    if [ $exit_code -eq 0 ]; then
        parse_valid_cert_to_json "$filepath" "$cert_content"
    else
        cert_content=$(openssl x509 -in "$filepath" -inform der -passin pass:'' 2> "$ERR_FILE")
        exit_code=$?
        if [ $exit_code -eq 0 ]; then
            parse_valid_cert_to_json "$filepath" "$cert_content"
        else
            generate_error_json "$filepath" "$(<"$ERR_FILE")"
        fi
    fi
    rm "$ERR_FILE"
}

# ==============================================================================
# Function: Processes Java KeyStore files (JKS, .p12, etc.).
# ==============================================================================
process_keytool_file() {
    local filepath="$1"
    local alias_list=""
    local working_pass=""
    local ERR_FILE=$(mktemp)
    
    # 1. Attempt with default passwords
    for pass in "${DEFAULT_PASSWORDS[@]}"; do
        alias_list=$(keytool -list -v -keystore "$filepath" -storepass "$pass" 2> /dev/null | grep "Alias name:" | awk -F': ' '{print $2}')
        if [ $? -eq 0 ] && [ -n "$alias_list" ]; then
            working_pass="$pass"
            break
        fi
    done

    # 2. If passwords failed, try keytool with NO password (explicit fallback for JKS)
    if [ -z "$alias_list" ]; then
        alias_list=$(keytool -list -v -keystore "$filepath" -storepass "" 2> /dev/null | grep "Alias name:" | awk -F': ' '{print $2}')
        if [ $? -eq 0 ] && [ -n "$alias_list" ]; then
            echo "Note: Keystore opened successfully without a password." >&2
            working_pass=""
        fi
    fi

    # If we have an alias list from any of the above methods, process it
    if [ -n "$alias_list" ]; then
        local first_alias_output=true
        echo "$alias_list" | while read -r alias; do
            if ! $first_alias_output; then echo ","; fi
            first_alias_output=false
            
            cert_pem_content=$(keytool -exportcert -alias "$alias" -keystore "$filepath" -storepass "$working_pass" -rfc 2> "$ERR_FILE")
            if [ $? -eq 0 ] && [ -n "$cert_pem_content" ]; then
                parse_valid_cert_to_json "${filepath} (alias: ${alias})" "$cert_pem_content"
            else
                generate_error_json "${filepath} (alias: ${alias})" "$(<"$ERR_FILE")"
            fi
        done
        rm "$ERR_FILE"
        return
    fi
    
    # 3. Final fallback for .p12 files using OpenSSL
    if [[ "${filepath,,}" == *.p12 ]]; then
        local certs_pem_content
        certs_pem_content=$(openssl pkcs12 -in "$filepath" -nokeys -nodes -password pass:'' 2> "$ERR_FILE")
        if [ $? -eq 0 ] && [ -n "$certs_pem_content" ];
        then
            echo "Note: Using OpenSSL passwordless fallback for .p12 file." >&2
            local first_cert_output=true
            local cert_count=0
            echo "$certs_pem_content" | awk '/BEGIN CERTIFICATE/,/END CERTIFICATE/' | while read -r single_cert_pem; do
                if ! $first_cert_output; then echo ","; fi
                first_cert_output=false
                ((cert_count++))
                parse_valid_cert_to_json "${filepath} (entry ${cert_count})" "$single_cert_pem"
            done
            rm "$ERR_FILE"
            return
        fi
    fi
    
    # If all attempts failed, generate the final error
    generate_error_json "$filepath" "Could not access keystore. All password and passwordless attempts failed."
    rm "$ERR_FILE"
}

# ==============================================================================
# Main script function
# ==============================================================================
main() {
    check_dependencies
    echo -e "${BLUE}Starting certificate scan...${NC}" >&2
    
    echo "[" > "$OUTPUT_FILE"
    local is_first_entry=true

    find / -type f \( \
        -iname "*.cer" -o -iname "*.crt" -o -iname "*.der" -o -iname "*.pem" -o \
        -iname "*.p7c" -o -iname "*.jks" -o -iname "*.keystore" -o -iname "*.p12" \
    \) 2>/dev/null | while read -r filepath; do
        printf -- "----------------------------------------------------------------------\n" >&2
        echo -e "${BOLD}Processing:${NC} $filepath" >&2
        
        local result_json
        case "${filepath,,}" in
            *.cer|*.crt|*.der|*.pem|*.p7c)
                result_json=$(process_openssl_file "$filepath")
                ;;
            *.jks|*.keystore|*.p12)
                if $KEYTOOL_AVAILABLE; then
                    result_json=$(process_keytool_file "$filepath")
                else
                    result_json=$(generate_error_json "$filepath" "Cannot process keystore: 'keytool' utility is not installed.")
                fi
                ;;
            *)
                continue
                ;;
        esac

        if [ -n "$result_json" ]; then
            if $is_first_entry; then
                is_first_entry=false
            else
                echo "," >> "$OUTPUT_FILE"
            fi
            echo "$result_json" >> "$OUTPUT_FILE"
        fi
    done

    echo "]" >> "$OUTPUT_FILE"
}

# --- Execution ---
main
echo -e "\n${BLUE}Finished. Results have been saved to: ${BOLD}$OUTPUT_FILE${NC}" >&2
